//basic instruction testing
//replace first lines of fixed memory with these instructions 

//note: dividing with a or multiple (???) negative numbers does not work. 
//NOTE MEM[7] IS THE ZERO REGISTER

//add reg A (preloaded with 6) with Mem[5] (preloaded with 4)
110 000 000 000 101 //add opcode 6, with 12 bit address of "5". A reg holds 10 
000 010 000 000 011    //tc to jump to address X and skip the 2nd add instruction. 
110 000 000 000 101 //add opcode 6, with 12 bit address of "5"  A reg holds 14 but we skip this! so A reg still holds 10.  
000 000 000 000 110 //tc to 6 so we can set extracode flag high
110 000 000 000 101 //subtract opcode 6 (with extracode high), with 12 bit address of "5". A reg holds 6 again.  
101 100 000 001 000 // transfer to storage, opcode 5 quarter 4, write A (holding 6) into Mem[8] 		
100 000 000 001 000 //clear and subtract the contents of Mem[8](which is = 6) so 1's complement of 6 is in A register 
101 110 000 000 101 // exchange A with Mem[5], so we see "6" in A register and 1's complement of 6 is in Mem[5]
110 000 000 001 000 //A holds 4, so add Mem[8] which holds 6, and save 10 to reg A. 
111 000 000 001 000 // MASK reg A holding 10 with Mem[8] holding 6. Our expected result is 2 bc 1010 & 0110 = 0010
000 000 000 000 110 //tc to 6 to get extracode high
111 000 000 001 000 // Multiply register A (holding 2) with Mem[8] holding +6, to get 12.  
 	use Mem[5] (holding -6) to get -12 with  111 000 000 000 101
000 000 000 000 110 //tc to 6 to get extracode high
001 000 000 001 010 // divide register A& L (l currently holds 12) with Mem[10] which holds 2 (preloaded). A is holding 2
001 000 000 000 111 //ccs with varying addresses to check all jumps. Mem[8] verified that >0 comparison worked. Mem[13] verified that -0 worked. Mem[7] verified that +0 worked. 
101 110 000 001 000 //xch with Mem[8] holding 6
101 000 000 001 001 //xch with Mem[9] holding 0
101 000 000 001 010 //xch Mem[10] holding 5
101 110 000 001 011 //xch with Mem[11] holding 0
finish instruction 111 111 111 111 111
